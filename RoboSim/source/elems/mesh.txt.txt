#pragma once

#include "pch.h"

#include "render/render_base.h"
#include "vertex_holder.h"
#include "elems/element.h"
#include "render/opengl_buffer_manager.h"

#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
namespace nelems
{
  class Mesh : public Element
  {
    
  public:

    Mesh() = default;

    virtual ~Mesh() { delete_buffers(); }
    
    bool load(const std::string& filepath, int nuMesh) {
        const uint32_t cMeshImportFlags =
            aiProcess_CalcTangentSpace |
            aiProcess_Triangulate |
            aiProcess_SortByPType |
            aiProcess_GenNormals |
            aiProcess_GenUVCoords |
            aiProcess_OptimizeMeshes |
            aiProcess_ValidateDataStructure;

        Assimp::Importer Importer;

        const aiScene* pScene = Importer.ReadFile(filepath.c_str(),
            cMeshImportFlags);

        if (pScene && pScene->HasMeshes())
        {

            mVertexIndices.clear();
            mVertices.clear();

            if (nuMesh == -1)
            {
                // Load all meshes
                for (unsigned int i = 0; i < pScene->mNumMeshes; ++i)
                {
                    auto* mesh = pScene->mMeshes[i];
                    writeloadmesh(mesh);
                }
            }
            else
            {
                auto* mesh = pScene->mMeshes[nuMesh];
                writeloadmesh(mesh);
            }


            init();
            return true;
        }
        return false;
    }
    void writeloadmesh(const aiMesh* mesh) {
        for (uint32_t i = 0; i < mesh->mNumVertices; i++)
        {
            VertexHolder vh;
            vh.mPos = { mesh->mVertices[i].x, mesh->mVertices[i].y ,mesh->mVertices[i].z };
            vh.mNormal = { mesh->mNormals[i].x, mesh->mNormals[i].y ,mesh->mNormals[i].z };

            add_vertex(vh);
        }

        for (size_t i = 0; i < mesh->mNumFaces; i++)
        {
            aiFace face = mesh->mFaces[i];

            for (size_t j = 0; j < face.mNumIndices; j++)
                add_vertex_index(face.mIndices[j]);
        }
    }
    void add_vertex(const VertexHolder& vertex) { mVertices.push_back(vertex);  }

    void add_vertex_index(unsigned int vertex_idx) { mVertexIndices.push_back(vertex_idx); }

    std::vector<unsigned int> get_vertex_indices() { return mVertexIndices; }

    std::size_t get_vertex_indices_size() const
    {
        return mVertexIndices.size();
    }
    std::size_t get_vertices_size() const
    {
        return mVertices.size();
    }

    void update(nshaders::Shader* shader) override
    {
      // pbr color
      shader->set_vec3(mColor,      "albedo");
      shader->set_f1(mRoughness,    "roughness");
      shader->set_f1(mMetallic,     "metallic");
      shader->set_f1(1.0f,          "ao");

    }
    
    glm::vec3 mColor = { 1.0f, 0.0f, 0.0f };
    float mRoughness = 0.2f;
    float mMetallic = 0.1f;

    void init()
    {
        mRenderBufferMgr = std::make_unique<nrender::OpenGL_VertexIndexBuffer>();
        create_buffers();
    }

    void create_buffers(){    mRenderBufferMgr->create_buffers(mVertices, mVertexIndices);}

    void delete_buffers(){ mRenderBufferMgr->delete_buffers(); }

    void render(){ mRenderBufferMgr->draw((int)mVertexIndices.size()); }

    void bind(){ mRenderBufferMgr->bind(); }

    void unbind(){ mRenderBufferMgr->unbind(); }


  private:
    // Buffers manager
    std::unique_ptr<nrender::VertexIndexBuffer> mRenderBufferMgr;
    
    // Vertices and indices
    std::vector<VertexHolder> mVertices;
    std::vector<unsigned int> mVertexIndices;

  };
}

